# 消息应用开发指南

## 1. 快速开始

### 开发环境准备
1. 确保SillyTavern正常运行
2. 打开浏览器开发者工具（F12）
3. 在Console中可以看到应用的日志输出
4. 修改代码后刷新页面即可看到效果

### 关键调试命令
```javascript
// 在浏览器控制台中使用这些命令进行调试

// 查看当前应用状态
window.MessageApp.currentView
window.MessageApp.currentFriendId

// 手动刷新好友列表
window.MessageApp.refreshFriendListUI()

// 查看提取的好友数据
window.MessageApp.friendRenderer.extractedFriends

// 强制重新渲染
window.MessageApp.show()
```

## 2. 常见修改场景

### 场景1: 修改消息气泡样式
**文件**: `app/message-app.css`
**位置**: `.message-bubble` 相关样式

```css
/* 修改我方消息气泡颜色 */
.message-bubble.sent {
  background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
  color: white;
}

/* 修改对方消息气泡颜色 */
.message-bubble.received {
  background: #f8f9fa;
  color: #333;
  border: 1px solid #dee2e6;
}

/* 修改气泡圆角 */
.message-bubble {
  border-radius: 18px;
}
```

### 场景2: 添加新的消息类型支持
**文件**: `app/message-renderer.js`
**方法**: `parseMessagesFromRawText`

```javascript
// 在现有的消息类型检测中添加新类型
if (messageType === '新消息类型') {
    sender = field1;
    number = field2;
    msgType = field3;
    content = field4;
    // 添加特殊处理逻辑
}

// 在渲染方法中添加对应的HTML生成逻辑
renderMessageBubble(message) {
    if (message.msgType === '新类型') {
        return this.renderSpecialMessage(message);
    }
    // 现有逻辑...
}
```

### 场景3: 修改好友列表显示格式
**文件**: `app/friend-renderer.js`
**方法**: `renderFriendsFromContext`

```javascript
// 修改好友项的HTML模板
const friendHTML = `
  <div class="message-item" data-friend-id="${friend.number}" data-friend-name="${friend.name}" data-is-group="false">
    <div class="message-avatar">${avatar}</div>
    <div class="message-content">
      <div class="message-name">${friend.name}</div>
      <div class="message-preview">${lastMessage}</div>
      <div class="message-time">${timeStr}</div>
      <!-- 添加新的元素 -->
      <div class="friend-status">在线</div>
    </div>
    <div class="message-meta">
      <div class="unread-count">${unreadCount}</div>
    </div>
  </div>
`;
```

### 场景4: 添加新的交互功能
**文件**: `app/message-app.js`
**方法**: `bindEvents`

```javascript
// 添加新的事件监听
bindEvents() {
    // 现有事件绑定...
    
    // 添加长按事件
    document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('.message-item')) {
            e.preventDefault();
            this.showContextMenu(e);
        }
    });
    
    // 添加双击事件
    document.addEventListener('dblclick', (e) => {
        if (e.target.closest('.message-bubble')) {
            this.handleMessageDoubleClick(e);
        }
    });
}

// 实现对应的处理方法
showContextMenu(event) {
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = `
        <div class="menu-item" data-action="copy">复制</div>
        <div class="menu-item" data-action="delete">删除</div>
        <div class="menu-item" data-action="forward">转发</div>
    `;
    document.body.appendChild(menu);
    
    // 设置菜单位置
    menu.style.left = event.pageX + 'px';
    menu.style.top = event.pageY + 'px';
}
```

## 3. 性能优化实践

### 减少DOM操作
```javascript
// 不好的做法：频繁操作DOM
messages.forEach(message => {
    const element = document.createElement('div');
    element.innerHTML = this.renderMessage(message);
    container.appendChild(element);
});

// 好的做法：批量操作DOM
const fragment = document.createDocumentFragment();
messages.forEach(message => {
    const element = document.createElement('div');
    element.innerHTML = this.renderMessage(message);
    fragment.appendChild(element);
});
container.appendChild(fragment);
```

### 使用防抖和节流
```javascript
// 防抖：延迟执行，适用于搜索输入
const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

// 节流：限制执行频率，适用于滚动事件
const throttle = (func, limit) => {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    }
};

// 使用示例
const debouncedSearch = debounce(this.searchMessages.bind(this), 300);
const throttledScroll = throttle(this.handleScroll.bind(this), 100);
```

## 4. 调试技巧

### 日志分级
```javascript
class Logger {
    static DEBUG = 0;
    static INFO = 1;
    static WARN = 2;
    static ERROR = 3;
    
    static level = Logger.INFO; // 设置日志级别
    
    static debug(message, ...args) {
        if (this.level <= this.DEBUG) {
            console.log(`[DEBUG] ${message}`, ...args);
        }
    }
    
    static info(message, ...args) {
        if (this.level <= this.INFO) {
            console.log(`[INFO] ${message}`, ...args);
        }
    }
    
    static warn(message, ...args) {
        if (this.level <= this.WARN) {
            console.warn(`[WARN] ${message}`, ...args);
        }
    }
    
    static error(message, ...args) {
        if (this.level <= this.ERROR) {
            console.error(`[ERROR] ${message}`, ...args);
        }
    }
}

// 使用示例
Logger.debug('好友数据提取完成', friends);
Logger.info('消息渲染开始');
Logger.warn('检测到性能问题');
Logger.error('消息发送失败', error);
```

### 性能监控
```javascript
class PerformanceMonitor {
    static timers = new Map();
    
    static start(label) {
        this.timers.set(label, performance.now());
    }
    
    static end(label) {
        const startTime = this.timers.get(label);
        if (startTime) {
            const duration = performance.now() - startTime;
            console.log(`[Performance] ${label}: ${duration.toFixed(2)}ms`);
            this.timers.delete(label);
            return duration;
        }
    }
    
    static measure(label, fn) {
        this.start(label);
        const result = fn();
        this.end(label);
        return result;
    }
}

// 使用示例
PerformanceMonitor.start('renderMessages');
this.renderMessages(messages);
PerformanceMonitor.end('renderMessages');

// 或者
const result = PerformanceMonitor.measure('parseMessages', () => {
    return this.parseMessages(rawText);
});
```

## 5. 常见问题解决

### 问题1: 好友列表不显示
**可能原因**:
- SillyTavern未准备就绪
- 聊天记录中没有好友标签
- 正则表达式匹配失败

**解决方法**:
```javascript
// 检查SillyTavern状态
if (!window.mobileContextEditor?.isSillyTavernReady()) {
    console.warn('SillyTavern未准备就绪，等待...');
    setTimeout(() => this.extractFriendsFromContext(), 1000);
    return;
}

// 检查聊天数据
const context = window.SillyTavern.getContext();
console.log('聊天数据:', context.chat);

// 测试正则表达式
const testText = '[好友id|张三|123]';
const matches = testText.match(/\[好友id\|([^|]+)\|(\d+)\]/g);
console.log('正则匹配结果:', matches);
```

### 问题2: 消息发送失败
**可能原因**:
- 输入框被禁用
- 发送按钮不可用
- 网络连接问题

**解决方法**:
```javascript
// 检查元素状态
const input = document.getElementById('send_textarea');
const button = document.getElementById('send_but');

console.log('输入框状态:', {
    exists: !!input,
    disabled: input?.disabled,
    value: input?.value
});

console.log('发送按钮状态:', {
    exists: !!button,
    disabled: button?.disabled,
    classList: button?.classList.toString()
});

// 使用备用发送方法
if (!this.sendToChat(message)) {
    this.sendToChatBackup(message);
}
```

### 问题3: 界面卡顿
**可能原因**:
- 消息数量过多
- DOM操作频繁
- 内存泄漏

**解决方法**:
```javascript
// 启用虚拟滚动
this.useVirtualScrolling = true;

// 限制渲染数量
const maxRenderCount = 100;
const messagesToRender = messages.slice(0, maxRenderCount);

// 清理事件监听器
window.removeEventListener('scroll', this.handleScroll);

// 清理缓存
this.messageCache.clear();
this.renderCache.clear();
```

## 6. 扩展开发

### 添加插件系统
```javascript
class PluginManager {
    constructor() {
        this.plugins = new Map();
    }
    
    register(name, plugin) {
        if (typeof plugin.init === 'function') {
            this.plugins.set(name, plugin);
            plugin.init();
            console.log(`插件 ${name} 已注册`);
        }
    }
    
    unregister(name) {
        const plugin = this.plugins.get(name);
        if (plugin && typeof plugin.destroy === 'function') {
            plugin.destroy();
            this.plugins.delete(name);
            console.log(`插件 ${name} 已卸载`);
        }
    }
    
    emit(event, data) {
        this.plugins.forEach(plugin => {
            if (typeof plugin.onEvent === 'function') {
                plugin.onEvent(event, data);
            }
        });
    }
}

// 插件示例
const emojiPlugin = {
    init() {
        console.log('表情插件初始化');
    },
    
    onEvent(event, data) {
        if (event === 'messageRender') {
            data.content = this.addEmojiSupport(data.content);
        }
    },
    
    addEmojiSupport(text) {
        return text.replace(/:smile:/g, '😊');
    },
    
    destroy() {
        console.log('表情插件销毁');
    }
};

// 使用插件
const pluginManager = new PluginManager();
pluginManager.register('emoji', emojiPlugin);
```

这个开发指南应该能帮助你更好地理解和修改消息应用。记住，修改代码时要小步快跑，每次只改一个小功能，及时测试，这样可以避免引入复杂的bug。
