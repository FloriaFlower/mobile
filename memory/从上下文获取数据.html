    /**
   * 处理AI消息接收事件
   * @param {number} messageId - 接收到的消息ID
   */
  async onMessageReceived(messageId) {
    try {
      console.log(`[Live App] 🎯 接收到AI消息事件，ID: ${messageId}`);

      // 检查直播是否活跃
      if (!this.liveApp || !this.liveApp.isLiveActive) {
        console.log('[Live App] 直播未激活，跳过处理');
        return;
      }

      // 检查是否有新消息
      const currentMessageCount = this.getCurrentMessageCount();
      console.log(`[Live App] 消息数量检查: 当前=${currentMessageCount}, 上次=${this.lastMessageCount}`);

      if (currentMessageCount <= this.lastMessageCount) {
        console.log('[Live App] 没有检测到新消息，跳过解析');
        return;
      }

      console.log(`[Live App] ✅ 检测到新消息，消息数量从 ${this.lastMessageCount} 增加到 ${currentMessageCount}`);
      this.lastMessageCount = currentMessageCount;

      // 触发数据解析
      console.log('[Live App] 开始解析新的直播数据...');
      await this.liveApp.parseNewLiveData();
    } catch (error) {
      console.error('[Live App] 处理消息接收事件失败:', error);
    }
  }

  /**
   * 获取当前消息数量
   */
  getCurrentMessageCount() {
    try {
      // 方法1: 使用SillyTavern.getContext().chat（正确的接口）
      if (typeof window !== 'undefined' && window.SillyTavern && typeof window.SillyTavern.getContext === 'function') {
        const context = window.SillyTavern.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const count = context.chat.length;
          console.log(`[Live App] 通过SillyTavern.getContext().chat获取到 ${count} 条消息`);
          return count;
        }
      }

      // 方法2: 使用mobileContextEditor作为备用
      const mobileContextEditor = window['mobileContextEditor'];
      if (mobileContextEditor && typeof mobileContextEditor.getCurrentChatData === 'function') {
        const chatData = mobileContextEditor.getCurrentChatData();
        if (chatData && chatData.messages && Array.isArray(chatData.messages)) {
          console.log(`[Live App] 通过mobileContextEditor获取到 ${chatData.messages.length} 条消息`);
          return chatData.messages.length;
        }
      }

      // 方法2: 尝试从父窗口获取chat变量
      if (typeof window !== 'undefined' && window.parent && window.parent.chat && Array.isArray(window.parent.chat)) {
        const count = window.parent.chat.length;
        console.log(`[Live App] 通过父窗口chat变量获取到 ${count} 条消息`);
        return count;
      }

      // 方法3: 使用getContext()方法（如果可用）
      if (typeof window !== 'undefined' && window.getContext && typeof window.getContext === 'function') {
        const context = window.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const count = context.chat.length;
          console.log(`[Live App] 通过getContext()获取到 ${count} 条消息`);
          return count;
        }
      }

      // 方法4: 尝试从父窗口获取getContext
      if (
        typeof window !== 'undefined' &&
        window.parent &&
        window.parent.getContext &&
        typeof window.parent.getContext === 'function'
      ) {
        const context = window.parent.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const count = context.chat.length;
          console.log(`[Live App] 通过父窗口getContext()获取到 ${count} 条消息`);
          return count;
        }
      }

      // 方法5: 使用mobileContextEditor作为备用（已在方法1中检查过）

      // 方法6: 尝试从父窗口获取mobileContextEditor
      if (typeof window !== 'undefined' && window.parent && window.parent['mobileContextEditor']) {
        const parentMobileContextEditor = window.parent['mobileContextEditor'];
        if (parentMobileContextEditor && typeof parentMobileContextEditor.getCurrentChatData === 'function') {
          const chatData = parentMobileContextEditor.getCurrentChatData();
          if (chatData && chatData.messages && Array.isArray(chatData.messages)) {
            console.log(`[Live App] 通过父窗口mobileContextEditor获取到 ${chatData.messages.length} 条消息`);
            return chatData.messages.length;
          }
        }
      }

      console.warn('[Live App] 无法获取消息数量，使用默认值0');
      return 0;
    } catch (error) {
      console.warn('[Live App] 获取消息数量失败:', error);
      return 0;
    }
  }

  /**
   * 更新消息计数
   */
  updateMessageCount() {
    this.lastMessageCount = this.getCurrentMessageCount();
    console.log(`[Live App] 初始化消息计数: ${this.lastMessageCount}`);
  }
}
// ==================== 数据解析器 ====================

/**
 * 直播数据解析器
 * 负责解析SillyTavern消息中的直播格式数据
 */
class LiveDataParser {
  constructor() {
    // 正则表达式模式
    this.patterns = {
      viewerCount: /\[直播\|本场人数\|([^\]]+)\]/g,
      liveContent: /\[直播\|直播内容\|([^\]]+)\]/g,
      normalDanmaku: /\[直播\|([^\|]+)\|弹幕\|([^\]]+)\]/g,
      giftDanmaku: /\[直播\|([^\|]+)\|打赏\|([^\]]+)\]/g,
      recommendedInteraction: /\[直播\|推荐互动\|([^\]]+)\]/g,
    };
  }

  /**
   * 解析直播数据
   * @param {string} content - 要解析的文本内容
   * @returns {Object} 解析后的直播数据
   */
  parseLiveData(content) {
    const liveData = {
      viewerCount: 0,
      liveContent: '',
      danmakuList: [],
      giftList: [],
      recommendedInteractions: [],
    };

    if (!content || typeof content !== 'string') {
      return liveData;
    }

    // 1. 解析直播人数
    liveData.viewerCount = this.parseViewerCount(content);

    // 2. 解析直播内容
    liveData.liveContent = this.parseLiveContent(content);

    // 3. 解析普通弹幕
    liveData.danmakuList = this.parseNormalDanmaku(content);

    // 4. 解析打赏弹幕
    const { danmakuList: giftDanmaku, giftList } = this.parseGiftDanmaku(content);
    liveData.danmakuList = liveData.danmakuList.concat(giftDanmaku);
    liveData.giftList = giftList;

    // 5. 解析推荐互动
    liveData.recommendedInteractions = this.parseRecommendedInteractions(content);

    return liveData;
  }

  /**
   * 解析直播人数
   */
  parseViewerCount(content) {
    const matches = [...content.matchAll(this.patterns.viewerCount)];
    if (matches.length === 0) return 0;

    // 取最后一个匹配（最新的人数）
    const lastMatch = matches[matches.length - 1];
    const viewerStr = lastMatch[1].trim();

    return this.formatViewerCount(viewerStr);
  }

  /**
   * 格式化观看人数
   */
  formatViewerCount(viewerStr) {
    // 移除非数字字符，保留数字和字母
    const cleanStr = viewerStr.replace(/[^\d\w]/g, '');

    // 尝试解析数字
    const num = parseInt(cleanStr);
    if (isNaN(num)) return 0;

    // 格式化大数字
    if (num >= 10000) {
      return (num / 10000).toFixed(1) + 'W';
    } else if (num >= 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }

    return num.toString();
  }

  /**
   * 解析直播内容
   */
  parseLiveContent(content) {
    const matches = [...content.matchAll(this.patterns.liveContent)];
    if (matches.length === 0) return '';

    // 取最后一个匹配（最新的内容）
    const lastMatch = matches[matches.length - 1];
    return lastMatch[1].trim();
  }

  /**
   * 解析普通弹幕
   */
  parseNormalDanmaku(content) {
    const danmakuList = [];
    const matches = [...content.matchAll(this.patterns.normalDanmaku)];

    matches.forEach((match, index) => {
      const username = match[1].trim();
      const danmakuContent = match[2].trim();

      danmakuList.push({
        id: Date.now() + index,
        username: username,
        content: danmakuContent,
        type: 'normal',
        timestamp: new Date().toLocaleString(),
      });
    });

    return danmakuList;
  }

  /**
   * 解析打赏弹幕
   */
  parseGiftDanmaku(content) {
    const danmakuList = [];
    const giftList = [];
    const matches = [...content.matchAll(this.patterns.giftDanmaku)];

    matches.forEach((match, index) => {
      const username = match[1].trim();
      const giftContent = match[2].trim();
      const timestamp = new Date().toLocaleString();

      // 添加到弹幕列表
      danmakuList.push({
        id: Date.now() + index + 10000, // 避免ID冲突
        username: username,
        content: giftContent,
        type: 'gift',
        timestamp: timestamp,
      });

      // 添加到礼物列表
      giftList.push({
        username: username,
        gift: giftContent,
        timestamp: timestamp,
      });
    });

    return { danmakuList, giftList };
  }

  /**
   * 解析推荐互动
   */
  parseRecommendedInteractions(content) {
    const interactions = [];
    const matches = [...content.matchAll(this.patterns.recommendedInteraction)];

    console.log(`[Live App] 推荐互动解析: 找到 ${matches.length} 个匹配项`);

    // 只取最后4个匹配项（最新的推荐互动）
    const recentMatches = matches.slice(-4);
    console.log(`[Live App] 取最新的 ${recentMatches.length} 个推荐互动`);

    recentMatches.forEach((match, index) => {
      const interactionContent = match[1].trim();
      console.log(`[Live App] 推荐互动 ${index + 1}: "${interactionContent}"`);
      if (!interactions.includes(interactionContent)) {
        interactions.push(interactionContent);
      }
    });

    console.log(`[Live App] 最终推荐互动列表:`, interactions);
    return interactions;
  }

  /**
   * 获取聊天消息内容
   */
  getChatContent() {
    try {
      // 方法1: 使用SillyTavern.getContext().chat（正确的接口）
      if (typeof window !== 'undefined' && window.SillyTavern && typeof window.SillyTavern.getContext === 'function') {
        const context = window.SillyTavern.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const messages = context.chat;
          if (messages && messages.length > 0) {
            const content = messages.map(msg => msg.mes || '').join('\n');
            console.log(`[Live App] 通过SillyTavern.getContext().chat获取到聊天内容，长度: ${content.length}`);
            return content;
          }
        }
      }

      // 方法2: 使用mobileContextEditor作为备用
      const mobileContextEditor = window['mobileContextEditor'];
      if (mobileContextEditor && typeof mobileContextEditor.getCurrentChatData === 'function') {
        const chatData = mobileContextEditor.getCurrentChatData();
        if (chatData && chatData.messages && Array.isArray(chatData.messages)) {
          const content = chatData.messages.map(msg => msg.mes || '').join('\n');
          console.log(`[Live App] 通过mobileContextEditor获取到聊天内容，长度: ${content.length}`);
          return content;
        }
      }

      // 方法2: 尝试从父窗口获取chat变量
      if (typeof window !== 'undefined' && window.parent && window.parent.chat && Array.isArray(window.parent.chat)) {
        const messages = window.parent.chat;
        if (messages && messages.length > 0) {
          const content = messages.map(msg => msg.mes || '').join('\n');
          console.log(`[Live App] 通过父窗口chat变量获取到聊天内容，长度: ${content.length}`);
          return content;
        }
      }

      // 方法3: 使用getContext()方法（如果可用）
      if (typeof window !== 'undefined' && window.getContext && typeof window.getContext === 'function') {
        const context = window.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const messages = context.chat;
          if (messages && messages.length > 0) {
            const content = messages.map(msg => msg.mes || '').join('\n');
            console.log(`[Live App] 通过getContext()获取到聊天内容，长度: ${content.length}`);
            return content;
          }
        }
      }

      // 方法4: 尝试从父窗口获取getContext
      if (
        typeof window !== 'undefined' &&
        window.parent &&
        window.parent.getContext &&
        typeof window.parent.getContext === 'function'
      ) {
        const context = window.parent.getContext();
        if (context && context.chat && Array.isArray(context.chat)) {
          const messages = context.chat;
          if (messages && messages.length > 0) {
            const content = messages.map(msg => msg.mes || '').join('\n');
            console.log(`[Live App] 通过父窗口getContext()获取到聊天内容，长度: ${content.length}`);
            return content;
          }
        }
      }

      // 方法5: 使用mobileContextEditor作为备用（已在方法1中检查过）

      // 方法6: 尝试从父窗口获取mobileContextEditor
      if (typeof window !== 'undefined' && window.parent && window.parent['mobileContextEditor']) {
        const parentMobileContextEditor = window.parent['mobileContextEditor'];
        if (parentMobileContextEditor && typeof parentMobileContextEditor.getCurrentChatData === 'function') {
          const chatData = parentMobileContextEditor.getCurrentChatData();
          if (chatData && chatData.messages && Array.isArray(chatData.messages)) {
            const content = chatData.messages.map(msg => msg.mes || '').join('\n');
            console.log(`[Live App] 通过父窗口mobileContextEditor获取到聊天内容，长度: ${content.length}`);
            return content;
          }
        }
      }

      console.warn('[Live App] 无法获取聊天内容');
      return '';
    } catch (error) {
      console.warn('[Live App] 获取聊天内容失败:', error);
      return '';
    }
  }
}