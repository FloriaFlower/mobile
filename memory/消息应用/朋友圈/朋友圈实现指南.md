# 朋友圈功能实现指南

## 实现步骤详解

### 第一步：扩展Message App基础架构

#### 1.1 修改message-app.js添加朋友圈状态
```javascript
class MessageApp {
  constructor() {
    this.currentView = 'list'; // 'list', 'addFriend', 'messageDetail', 'friendsCircle'
    this.currentTab = 'friends'; // 'friends', 'circle'
    
    // 朋友圈相关状态
    this.friendsCircleManager = null;
    this.friendsCircleEventListener = null;
    this.friendsCircleRenderer = null;
    
    // 用户签名（存储在localStorage）
    this.userSignature = localStorage.getItem('friendsCircle_userSignature') || '这个人很懒，什么都没留下';
  }
}
```

#### 1.2 添加页面切换栏渲染
```javascript
renderTabSwitcher() {
  return `
    <div class="message-tab-switcher">
      <button class="tab-btn ${this.currentTab === 'friends' ? 'active' : ''}" 
              data-tab="friends">
        <i class="fas fa-user-friends"></i>
        <span>好友</span>
      </button>
      <button class="tab-btn ${this.currentTab === 'circle' ? 'active' : ''}"
              data-tab="circle">
        <i class="fas fa-globe"></i>
        <span>朋友圈</span>
      </button>
    </div>
  `;
}
```

### 第二步：创建朋友圈核心组件

#### 2.1 朋友圈管理器 (friends-circle-manager.js)
```javascript
class FriendsCircleManager {
  constructor() {
    this.friendsCircleData = new Map(); // 存储朋友圈数据
    this.likesData = new Map(); // 存储点赞数据
    this.lastProcessedMessageId = null;
    
    // 朋友圈格式正则表达式
    this.patterns = {
      textCircle: /\[朋友圈\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g,
      visualCircle: /\[朋友圈\|([^|]+)\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g,
      circleReply: /\[朋友圈回复\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g
    };
  }
  
  // 解析朋友圈数据
  parseFriendsCircleData(chatContent) {
    const circles = new Map();
    
    // 解析文字朋友圈
    let match;
    while ((match = this.patterns.textCircle.exec(chatContent)) !== null) {
      const [fullMatch, author, friendId, floorId, content] = match;
      
      if (!circles.has(floorId)) {
        circles.set(floorId, {
          id: floorId,
          author: author,
          friendId: friendId,
          type: 'text',
          content: content,
          timestamp: Date.now(),
          replies: [],
          likes: this.getLikeCount(floorId),
          isLiked: this.isLiked(floorId)
        });
      }
    }
    
    // 解析视觉朋友圈
    this.patterns.visualCircle.lastIndex = 0;
    while ((match = this.patterns.visualCircle.exec(chatContent)) !== null) {
      const [fullMatch, author, friendId, floorId, imageDesc, textContent] = match;
      
      if (!circles.has(floorId)) {
        circles.set(floorId, {
          id: floorId,
          author: author,
          friendId: friendId,
          type: 'visual',
          imageDescription: imageDesc,
          content: textContent || '',
          timestamp: Date.now(),
          replies: [],
          likes: this.getLikeCount(floorId),
          isLiked: this.isLiked(floorId)
        });
      }
    }
    
    // 解析回复
    this.patterns.circleReply.lastIndex = 0;
    while ((match = this.patterns.circleReply.exec(chatContent)) !== null) {
      const [fullMatch, replyAuthor, replyFriendId, floorId, replyContent] = match;
      
      if (circles.has(floorId)) {
        const circle = circles.get(floorId);
        circle.replies.push({
          id: `reply_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          author: replyAuthor,
          friendId: replyFriendId,
          content: replyContent,
          timestamp: Date.now(),
          likes: 0,
          isLiked: false
        });
        
        // 更新朋友圈时间戳（有新回复）
        circle.timestamp = Date.now();
      }
    }
    
    return circles;
  }
  
  // 获取排序后的朋友圈列表
  getSortedFriendsCircles() {
    const circles = Array.from(this.friendsCircleData.values());
    
    // 按时间戳降序排序（最新的在前）
    return circles.sort((a, b) => b.timestamp - a.timestamp);
  }
  
  // 点赞相关方法
  toggleLike(circleId) {
    const currentLikes = this.getLikeCount(circleId);
    const isCurrentlyLiked = this.isLiked(circleId);
    
    if (isCurrentlyLiked) {
      this.likesData.set(circleId, { likes: currentLikes - 1, isLiked: false });
    } else {
      this.likesData.set(circleId, { likes: currentLikes + 1, isLiked: true });
    }
    
    return this.likesData.get(circleId);
  }
  
  getLikeCount(circleId) {
    return this.likesData.get(circleId)?.likes || Math.floor(Math.random() * 20) + 5;
  }
  
  isLiked(circleId) {
    return this.likesData.get(circleId)?.isLiked || false;
  }
}
```

#### 2.2 朋友圈事件监听器 (friends-circle-event-listener.js)
```javascript
class FriendsCircleEventListener {
  constructor(messageApp) {
    this.messageApp = messageApp;
    this.isListening = false;
    this.lastMessageCount = 0;
    this.messageReceivedHandler = this.onMessageReceived.bind(this);
  }
  
  // 复用live-app的智能检测系统
  startListening() {
    if (this.isListening) return;
    
    try {
      // 方法1: 使用SillyTavern.getContext().eventSource
      if (window.SillyTavern?.getContext) {
        const context = window.SillyTavern.getContext();
        if (context?.eventSource?.on && context.event_types) {
          context.eventSource.on(context.event_types.MESSAGE_RECEIVED, this.messageReceivedHandler);
          this.isListening = true;
          console.log('[Friends Circle] ✅ 成功监听SillyTavern消息事件');
          this.updateMessageCount();
          return;
        }
      }
      
      // 方法2: 使用全局eventOn函数
      if (typeof eventOn === 'function' && tavern_events?.MESSAGE_RECEIVED) {
        eventOn(tavern_events.MESSAGE_RECEIVED, this.messageReceivedHandler);
        this.isListening = true;
        console.log('[Friends Circle] ✅ 成功使用全局eventOn监听');
        this.updateMessageCount();
        return;
      }
      
      // 方法3: 使用父窗口eventSource
      if (window.parent?.eventSource?.on && window.parent.event_types?.MESSAGE_RECEIVED) {
        window.parent.eventSource.on(window.parent.event_types.MESSAGE_RECEIVED, this.messageReceivedHandler);
        this.isListening = true;
        console.log('[Friends Circle] ✅ 成功使用父窗口eventSource监听');
        this.updateMessageCount();
        return;
      }
      
      // 备用方案：轮询
      this.startPolling();
    } catch (error) {
      console.error('[Friends Circle] 设置事件监听失败:', error);
      this.startPolling();
    }
  }
  
  async onMessageReceived(messageId) {
    try {
      console.log(`[Friends Circle] 接收到消息事件: ${messageId}`);
      
      // 检查是否在朋友圈页面
      if (this.messageApp.currentTab !== 'circle') {
        return;
      }
      
      // 检查消息数量变化
      const currentMessageCount = this.getCurrentMessageCount();
      if (currentMessageCount <= this.lastMessageCount) {
        return;
      }
      
      console.log(`[Friends Circle] 检测到新消息: ${this.lastMessageCount} → ${currentMessageCount}`);
      this.lastMessageCount = currentMessageCount;
      
      // 触发朋友圈数据更新
      await this.messageApp.refreshFriendsCircle();
    } catch (error) {
      console.error('[Friends Circle] 处理消息事件失败:', error);
    }
  }
  
  getCurrentMessageCount() {
    // 复用message-app的消息数量获取逻辑
    try {
      if (window.SillyTavern?.getContext) {
        const context = window.SillyTavern.getContext();
        if (context?.chat && Array.isArray(context.chat)) {
          return context.chat.length;
        }
      }
      
      if (window.mobileContextEditor?.getCurrentChatData) {
        const chatData = window.mobileContextEditor.getCurrentChatData();
        if (chatData?.messages && Array.isArray(chatData.messages)) {
          return chatData.messages.length;
        }
      }
      
      if (window.parent?.chat && Array.isArray(window.parent.chat)) {
        return window.parent.chat.length;
      }
      
      return 0;
    } catch (error) {
      console.warn('[Friends Circle] 获取消息数量失败:', error);
      return 0;
    }
  }
  
  updateMessageCount() {
    this.lastMessageCount = this.getCurrentMessageCount();
    console.log(`[Friends Circle] 初始化消息计数: ${this.lastMessageCount}`);
  }
  
  startPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    
    this.updateMessageCount();
    this.pollingInterval = setInterval(() => {
      this.checkForNewMessages();
    }, 2000);
    
    this.isListening = true;
    console.log('[Friends Circle] ✅ 启动轮询监听方案');
  }
  
  checkForNewMessages() {
    const currentMessageCount = this.getCurrentMessageCount();
    if (currentMessageCount > this.lastMessageCount) {
      console.log(`[Friends Circle] 轮询检测到新消息: ${this.lastMessageCount} → ${currentMessageCount}`);
      this.onMessageReceived(currentMessageCount);
    }
  }
  
  stopListening() {
    if (!this.isListening) return;
    
    try {
      // 尝试移除事件监听器
      if (window.SillyTavern?.getContext) {
        const context = window.SillyTavern.getContext();
        if (context?.eventSource?.off && context.event_types) {
          context.eventSource.off(context.event_types.MESSAGE_RECEIVED, this.messageReceivedHandler);
        }
      }
      
      // 清除轮询
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }
      
      this.isListening = false;
      console.log('[Friends Circle] 已停止监听事件');
    } catch (error) {
      console.error('[Friends Circle] 停止监听失败:', error);
    }
  }
}
```

### 第三步：实现UI渲染器

#### 3.1 朋友圈渲染器 (friends-circle-renderer.js)
```javascript
class FriendsCircleRenderer {
  constructor(messageApp) {
    this.messageApp = messageApp;
    this.publishModal = null;
  }
  
  // 渲染朋友圈页面
  renderFriendsCirclePage() {
    const userInfo = this.renderUserInfo();
    const circlesList = this.renderCirclesList();
    
    return `
      <div class="friends-circle-page">
        ${userInfo}
        <div class="circles-container">
          ${circlesList}
        </div>
      </div>
    `;
  }
  
  // 渲染用户信息区域
  renderUserInfo() {
    const userName = this.getCurrentUserName();
    const userAvatar = this.getCurrentUserAvatar();
    const userSignature = this.messageApp.userSignature;
    
    return `
      <div class="user-info-section">
        <div class="user-avatar">
          <img src="${userAvatar}" alt="${userName}" />
        </div>
        <div class="user-details">
          <div class="user-name">${userName}</div>
          <div class="user-signature" onclick="window.messageApp.editUserSignature()">
            ${userSignature}
            <i class="fas fa-edit signature-edit-icon"></i>
          </div>
        </div>
      </div>
    `;
  }
  
  // 渲染朋友圈列表
  renderCirclesList() {
    if (!this.messageApp.friendsCircleManager) {
      return '<div class="empty-circles">暂无朋友圈</div>';
    }
    
    const circles = this.messageApp.friendsCircleManager.getSortedFriendsCircles();
    
    if (circles.length === 0) {
      return '<div class="empty-circles">暂无朋友圈</div>';
    }
    
    return circles.map(circle => this.renderSingleCircle(circle)).join('');
  }
  
  // 渲染单个朋友圈
  renderSingleCircle(circle) {
    const friendAvatar = this.getFriendAvatar(circle.friendId);
    const timeStr = this.formatTime(circle.timestamp);
    const contentHtml = this.renderCircleContent(circle);
    const repliesHtml = this.renderCircleReplies(circle.replies);
    const actionsHtml = this.renderCircleActions(circle);
    
    return `
      <div class="circle-item" data-circle-id="${circle.id}">
        <div class="circle-header">
          <div class="friend-avatar">
            <img src="${friendAvatar}" alt="${circle.author}" />
          </div>
          <div class="friend-info">
            <div class="friend-name">${circle.author}</div>
            <div class="circle-time">${timeStr}</div>
          </div>
        </div>
        
        <div class="circle-content">
          ${contentHtml}
        </div>
        
        <div class="circle-actions">
          ${actionsHtml}
        </div>
        
        <div class="circle-replies">
          ${repliesHtml}
        </div>
        
        <div class="reply-input-container" id="reply-input-${circle.id}" style="display: none;">
          <input type="text" class="reply-input" placeholder="写下你的想法..." />
          <button class="reply-send-btn" onclick="window.messageApp.sendCircleReply('${circle.id}')">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    `;
  }
  
  // 渲染朋友圈内容
  renderCircleContent(circle) {
    if (circle.type === 'visual') {
      return `
        <div class="visual-circle-content">
          <div class="image-placeholder">
            <i class="fas fa-image"></i>
            <span>${circle.imageDescription}</span>
          </div>
          ${circle.content ? `<div class="text-content">${circle.content}</div>` : ''}
        </div>
      `;
    } else {
      return `<div class="text-circle-content">${circle.content}</div>`;
    }
  }
  
  // 渲染朋友圈操作按钮
  renderCircleActions(circle) {
    const likeIcon = circle.isLiked ? 'fas fa-heart liked' : 'far fa-heart';
    
    return `
      <button class="action-btn like-btn" onclick="window.messageApp.toggleCircleLike('${circle.id}')">
        <i class="${likeIcon}"></i>
        <span class="like-count">${circle.likes}</span>
      </button>
      <button class="action-btn reply-btn" onclick="window.messageApp.toggleReplyInput('${circle.id}')">
        <i class="fas fa-comment"></i>
        <span>回复</span>
      </button>
    `;
  }
  
  // 渲染朋友圈回复
  renderCircleReplies(replies) {
    if (!replies || replies.length === 0) {
      return '';
    }
    
    const repliesHtml = replies.map(reply => {
      const replyAvatar = this.getFriendAvatar(reply.friendId);
      const timeStr = this.formatTime(reply.timestamp);
      
      return `
        <div class="circle-reply">
          <div class="reply-avatar">
            <img src="${replyAvatar}" alt="${reply.author}" />
          </div>
          <div class="reply-content">
            <div class="reply-author">${reply.author}</div>
            <div class="reply-text">${reply.content}</div>
            <div class="reply-time">${timeStr}</div>
          </div>
        </div>
      `;
    }).join('');
    
    return `
      <div class="replies-list">
        <div class="replies-header">
          <span>${replies.length} 条回复</span>
        </div>
        ${repliesHtml}
      </div>
    `;
  }
  
  // 获取好友头像
  getFriendAvatar(friendId) {
    // 复用message-app的好友头像获取逻辑
    if (window.friendRenderer?.getFriendAvatar) {
      return window.friendRenderer.getFriendAvatar(friendId);
    }
    return '/images/default-avatar.png';
  }
  
  // 获取当前用户信息
  getCurrentUserName() {
    return window.name1 || '我';
  }
  
  getCurrentUserAvatar() {
    // 获取当前用户头像
    return '/images/user-avatar.png';
  }
  
  // 格式化时间
  formatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffMins < 1) {
      return '刚刚';
    } else if (diffMins < 60) {
      return `${diffMins}分钟前`;
    } else if (diffHours < 24) {
      return `${diffHours}小时前`;
    } else if (diffDays < 7) {
      return `${diffDays}天前`;
    } else {
      return date.toLocaleDateString('zh-CN', {
        month: 'short',
        day: 'numeric',
      });
    }
  }
}
```

### 第四步：实现发布功能

#### 4.1 发布弹窗实现
```javascript
// 在friends-circle-renderer.js中添加
showPublishModal() {
  if (this.publishModal) {
    this.publishModal.remove();
  }
  
  this.publishModal = document.createElement('div');
  this.publishModal.className = 'friends-circle-publish-modal';
  this.publishModal.innerHTML = `
    <div class="modal-overlay" onclick="window.messageApp.hidePublishModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>发布朋友圈</h3>
        <button class="modal-close" onclick="window.messageApp.hidePublishModal()">×</button>
      </div>
      <div class="publish-options">
        <button class="publish-option-btn" onclick="window.messageApp.showTextPublish()">
          <i class="fas fa-font"></i>
          <span>发文字</span>
        </button>
        <button class="publish-option-btn" onclick="window.messageApp.showImagePublish()">
          <i class="fas fa-image"></i>
          <span>发图片</span>
        </button>
      </div>
    </div>
  `;
  
  // 使用手机容器定位
  const mobileContainer = document.querySelector('.mobile-phone-container');
  if (mobileContainer) {
    mobileContainer.appendChild(this.publishModal);
  } else {
    document.body.appendChild(this.publishModal);
  }
}
```

### 第五步：集成到Message App

#### 5.1 在message-app.js中添加朋友圈方法
```javascript
// 初始化朋友圈功能
initFriendsCircle() {
  this.friendsCircleManager = new FriendsCircleManager();
  this.friendsCircleEventListener = new FriendsCircleEventListener(this);
  this.friendsCircleRenderer = new FriendsCircleRenderer(this);
}

// 切换到朋友圈页面
showFriendsCircle() {
  this.currentTab = 'circle';
  this.currentView = 'list';
  
  // 开始监听事件
  if (this.friendsCircleEventListener) {
    this.friendsCircleEventListener.startListening();
  }
  
  // 刷新界面
  this.refreshApp();
}

// 刷新朋友圈数据
async refreshFriendsCircle() {
  if (!this.friendsCircleManager) return;
  
  try {
    // 获取聊天内容
    const chatContent = await this.getChatContent();
    
    // 解析朋友圈数据
    const newCircles = this.friendsCircleManager.parseFriendsCircleData(chatContent);
    
    // 更新数据
    this.friendsCircleManager.friendsCircleData = newCircles;
    
    // 刷新界面
    if (this.currentTab === 'circle') {
      this.refreshApp();
    }
  } catch (error) {
    console.error('[Friends Circle] 刷新朋友圈数据失败:', error);
  }
}

// 获取聊天内容
async getChatContent() {
  // 复用现有的聊天内容获取逻辑
  if (window.contextMonitor?.getCurrentChatMessages) {
    const chatData = await window.contextMonitor.getCurrentChatMessages();
    return chatData.messages.map(msg => msg.mes).join('\n');
  }
  return '';
}
```

这个实现指南提供了朋友圈功能的核心实现框架，基于对现有代码的深入学习，确保了技术方案的可行性和一致性。
