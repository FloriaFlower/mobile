# 朋友圈功能技术学习总结

## 现有应用架构深度分析

### 1. Message App 事件系统

#### 智能事件检测机制
```javascript
// message-app.js 中的智能检测系统
smartDetectEventSystem() {
  const detectionMethods = [
    // 方法1: SillyTavern.getContext().eventSource（推荐）
    () => {
      if (window.SillyTavern?.getContext) {
        const context = window.SillyTavern.getContext();
        if (context?.eventSource?.on && context.event_types) {
          return {
            eventSource: context.eventSource,
            event_types: context.event_types,
            foundIn: 'SillyTavern.getContext()'
          };
        }
      }
      return null;
    },
    
    // 方法2: 全局eventOn函数
    () => {
      if (typeof eventOn === 'function' && tavern_events?.MESSAGE_RECEIVED) {
        return {
          eventSource: { on: eventOn, off: eventOff || (() => {}) },
          event_types: tavern_events,
          foundIn: 'global eventOn'
        };
      }
      return null;
    },
    
    // 方法3: 父窗口eventSource
    () => {
      if (window.parent?.eventSource?.on && window.parent.event_types?.MESSAGE_RECEIVED) {
        return {
          eventSource: window.parent.eventSource,
          event_types: window.parent.event_types,
          foundIn: 'parent.eventSource'
        };
      }
      return null;
    }
  ];
}
```

#### 消息数量获取机制
```javascript
getCurrentMessageCount() {
  // 方法1: 使用SillyTavern.getContext().chat（正确的接口）
  if (window.SillyTavern?.getContext) {
    const context = window.SillyTavern.getContext();
    if (context?.chat && Array.isArray(context.chat)) {
      return context.chat.length;
    }
  }
  
  // 方法2: 使用mobileContextEditor作为备用
  const mobileContextEditor = window.mobileContextEditor;
  if (mobileContextEditor?.getCurrentChatData) {
    const chatData = mobileContextEditor.getCurrentChatData();
    if (chatData?.messages && Array.isArray(chatData.messages)) {
      return chatData.messages.length;
    }
  }
  
  // 方法3: 尝试从父窗口获取chat变量
  if (window.parent?.chat && Array.isArray(window.parent.chat)) {
    return window.parent.chat.length;
  }
  
  return 0;
}
```

### 2. Live App 事件监听模式

#### 事件监听器类设计
```javascript
class LiveEventListener {
  constructor(liveApp) {
    this.liveApp = liveApp;
    this.isListening = false;
    this.lastMessageCount = 0;
    this.pollingInterval = null;
    this.messageReceivedHandler = this.onMessageReceived.bind(this);
  }
  
  startListening() {
    // 检查SillyTavern接口可用性
    console.log('[Live App] 检查SillyTavern接口可用性:', {
      'window.SillyTavern': !!window?.SillyTavern,
      'window.SillyTavern.getContext': typeof window?.SillyTavern?.getContext,
      eventOn: typeof eventOn,
      tavern_events: typeof tavern_events,
      mobileContextEditor: !!window?.mobileContextEditor,
    });
    
    // 多种方式尝试监听
    // 如果都失败，使用轮询作为备用方案
  }
}
```

#### 消息解析机制
```javascript
class LiveDataParser {
  constructor() {
    this.patterns = {
      viewerCount: /\[直播\|观看人数\|(\d+)\]/g,
      liveContent: /\[直播\|直播内容\|([^\]]+)\]/g,
      danmaku: /\[直播\|弹幕\|([^|]+)\|([^\]]+)\]/g,
      gift: /\[直播\|礼物\|([^|]+)\|([^|]+)\|([^\]]+)\]/g,
      recommendedInteraction: /\[直播\|推荐互动\|([^\]]+)\]/g,
    };
  }
  
  parseLiveData(content) {
    const liveData = {
      viewerCount: 0,
      liveContent: '',
      danmakuList: [],
      giftList: [],
      recommendedInteractions: []
    };
    
    // 使用正则表达式解析各种格式
    liveData.viewerCount = this.parseViewerCount(content);
    liveData.liveContent = this.parseLiveContent(content);
    // ...
    
    return liveData;
  }
}
```

### 3. Forum App 交互设计

#### 点赞系统实现
```javascript
class ForumUI {
  constructor() {
    // 点赞数据存储
    this.likesData = {}; // { threadId: { likes: number, isLiked: boolean } }
    this.replyLikesData = {}; // { replyId: { likes: number, isLiked: boolean } }
  }
  
  toggleThreadLike(threadId) {
    this.initThreadLikeData(threadId);
    const likeData = this.likesData[threadId];
    
    if (likeData.isLiked) {
      likeData.likes--;
      likeData.isLiked = false;
    } else {
      likeData.likes++;
      likeData.isLiked = true;
    }
    
    this.updateAllThreadLikeButtons(threadId);
    return likeData;
  }
  
  addLikeAnimation(button) {
    button.style.transform = 'scale(1.2)';
    button.style.transition = 'transform 0.2s ease';
    setTimeout(() => {
      button.style.transform = 'scale(1)';
    }, 200);
  }
}
```

#### 回复系统设计
```javascript
// 主回复功能
submitMainReply() {
  const input = document.querySelector('.comment-input-bar input');
  const content = input.value.trim();
  
  if (!content) {
    alert('请输入回复内容');
    return;
  }
  
  // 构建回复格式
  const replyFormat = `[回复|我|${this.currentThreadId}|${content}]`;
  
  // 发送给AI
  if (window.forumManager.sendReplyToAPI) {
    window.forumManager.sendReplyToAPI(fullReply)
      .then(() => {
        console.log('[Forum UI] 回复已通过API发送给模型');
        this.refreshThreadList();
      })
      .catch(error => {
        console.error('[Forum UI] API发送回复失败:', error);
      });
  }
}

// 楼中楼回复功能
submitSubReply(replyId, parentFloor, parentAuthor) {
  const content = textarea.value.trim();
  
  // 构建楼中楼回复格式
  const replyFormat = `[回复|我|${this.currentThreadId}|回复${parentReply.author}：${content}]`;
  
  this.sendReplyToForum(subReplyData);
}
```

#### 消息解析和去重
```javascript
parseForumContent(forumContent) {
  const threads = [];
  const replies = {};
  
  // 解析标题格式: [标题|发帖人昵称|帖子id|标题内容|帖子详情]
  const titleRegex = /\[标题\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g;
  // 解析回复格式: [回复|回帖人昵称|帖子id|回复内容]
  const replyRegex = /\[回复\|([^|]+)\|([^|]+)\|([^\]]+)\]/g;
  // 解析楼中楼格式: [楼中楼|回帖人昵称|帖子id|父楼层|回复内容]
  const subReplyRegex = /\[楼中楼\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g;
  
  // 解析并关联数据
  // 避免重复解析相同内容
}
```

### 4. Mobile Upload 文件上传机制

#### 文件上传API集成
```javascript
class MobileUploadManager {
  async uploadFile(file) {
    // 验证文件大小
    if (file.size > this.maxFileSize) {
      throw new Error(`文件大小超过限制 (${this.maxFileSize / 1024 / 1024}MB)`);
    }
    
    // 生成唯一文件名
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const fileExtension = file.name.split('.').pop() || 'txt';
    const uniqueFileName = `mobile_upload_${timestamp}_${randomId}.${fileExtension}`;
    
    // 调用SillyTavern API
    const response = await fetch('/api/files/upload', {
      method: 'POST',
      headers: getRequestHeaders(),
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`上传失败: ${response.status} ${response.statusText}`);
    }
    
    const result = await response.json();
    return result;
  }
}
```

#### 请求头获取机制
```javascript
function getRequestHeaders() {
  // 方法1：使用SillyTavern的getContext
  if (window.SillyTavern?.getContext) {
    const context = window.SillyTavern.getContext();
    if (context?.getRequestHeaders) {
      return context.getRequestHeaders();
    }
  }
  
  // 方法2：使用全局getRequestHeaders函数
  if (window.getRequestHeaders) {
    return window.getRequestHeaders();
  }
  
  // 方法3：使用token全局变量
  if (window.token) {
    return {
      'Content-Type': 'application/json',
      'X-CSRF-Token': window.token,
    };
  }
  
  // 回退方案：基本头部
  return {
    'Content-Type': 'application/json',
  };
}
```

### 5. Style Config Manager 样式管理

#### Data Bank API集成
```javascript
class StyleConfigManager {
  async importSillyTavernCore() {
    try {
      // 动态导入chats.js模块
      const chatsModule = await import('../../../../chats.js');
      
      getDataBankAttachmentsForSource = chatsModule.getDataBankAttachmentsForSource;
      getFileAttachment = chatsModule.getFileAttachment;
      uploadFileAttachmentToServer = chatsModule.uploadFileAttachmentToServer;
      deleteAttachment = chatsModule.deleteAttachment;
      
      sillyTavernCoreImported = true;
    } catch (error) {
      console.warn('导入SillyTavern模块失败，使用localStorage备用方案:', error);
    }
  }
}
```

#### 响应式设计实现
```css
/* 响应式设计 */
@media (max-width: 768px) {
  .style-config-app {
    margin: 10px;
  }
  
  .config-section {
    padding: 15px;
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  .form-input, .form-select, .form-textarea {
    font-size: 16px; /* 防止iOS缩放 */
    padding: 12px;
  }
}
```

## 关键技术要点总结

### 1. 事件监听最佳实践
- 多层检测机制确保兼容性
- 智能降级到轮询备用方案
- 事件处理函数绑定this上下文
- 防抖处理避免频繁触发

### 2. 消息解析策略
- 使用正则表达式匹配特定格式
- 支持多种消息类型的解析
- 实现去重和排序逻辑
- 错误处理和容错机制

### 3. UI交互设计
- 响应式弹窗定位
- 移动端触摸优化
- 动画效果增强体验
- 状态管理和数据绑定

### 4. 文件上传集成
- SillyTavern API标准调用
- 文件类型和大小验证
- 唯一文件名生成策略
- 错误处理和用户反馈

### 5. 样式管理机制
- Data Bank存储配置
- localStorage备用方案
- 动态样式应用
- 响应式设计适配

## 朋友圈功能应用要点

### 1. 事件监听复用
- 使用live-app的智能检测系统
- 监听MESSAGE_RECEIVED事件
- 实现消息变化检测

### 2. 消息格式设计
```javascript
const FRIENDS_CIRCLE_PATTERNS = {
  text: /\[朋友圈\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g,
  visual: /\[朋友圈\|([^|]+)\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g,
  reply: /\[朋友圈回复\|([^|]+)\|([^|]+)\|([^|]+)\|([^\]]+)\]/g
};
```

### 3. 交互功能实现
- 参考forum-app的点赞系统
- 实现回复输入和发送
- 集成文件上传功能

### 4. 数据管理策略
- 本地状态管理
- localStorage存储用户配置
- 排序和去重处理

这些技术要点为朋友圈功能的实现提供了坚实的基础，确保了功能的稳定性和用户体验的一致性。
